flush Some useful procedures

flush --
newhdr immediate
proc asm
begin
    dict load
    8 add
    copy bload
    128 or
    swap bstore
    return
end

flush --
flush Assembles the following word regardless of immediacy
newhdr '
proc asm
begin
    prs_nxt drop
    prs_wrd find de_name add calign asm
    return
end immediate


flush --
flush Nicer comment syntax
newhdr #
proc asm
begin
    ' flush
    return
end immediate

# Now we have comments syntax, so lets define function syntax

# --
newhdr fn:
proc asm
begin
    newhdr
    proc asm
    begin
    return
end

# --
fn: end-fn
    lit return asm
    ' end
    return
end immediate

# Now loops

# -- target
fn: do
    here load
end-fn immediate

# target --
fn: loop
    lit branch asm
    here load 8 add sub asm
end-fn immediate

# Some output helpers

# --
fn: defstr:
    newhdr
    str asm
end-fn

defstr: nl
1 basm
10 basm
0 basm

defstr: tab
1 basm
9 basm
0 basm

# str len --
fn: println
    print nl print
end-fn

# And a dictionary walk

# ptr --
fn: walk
    do
        tab print
        copy de_name println
        load copy
    loop

    drop
end-fn

fn: const:
    newhdr
    const asm
    asm
end-fn

92 const: backslash

# --
fn: \
    do
        in_ptr load backslash prs_ch in_adv
        swap not or not
    loop

    in_ptr load 1 add in_adv drop drop
end-fn immediate

\
    The above magic little definition lets us do block comments
    like these.
\

34 const: quotes

# start end -- start len
fn: string-from-range
    over sub
end-fn

fn: var-add         \ n var -- \            swap over load add swap store           end-fn
fn: copy-pair       \ a b -- a b a b \      over over                               end-fn
fn: asm-string      \ string length -- \    swap over here load scopy here var-add  end-fn
fn: realign-arena   \ -- \                  here load calign here store             end-fn

fn: patch-target
    \ patch-address -- \
    here load over 8 add sub
    swap store
end-fn

fn: if
    \ -- patch-address \
    lit zeroes asm
    lit eq asm
    lit branch asm
    here load
    0 asm
end-fn immediate

fn: end-if
    \ patch-address -- \
    patch-target
end-fn immediate

# Multiline strings should be easy to implement; each go of the loop we `scopy` the stuff we've found
# so far into the arena, and finally return pointers.
# -- string length
fn: s"
    \
        Block comments even work inside assembly mode
    \

    mode load if
        # This will be patched later so that an inline string can be skipped
        lit jump asm
        here load push
        0 asm
    end-if

    here load
    do
        in_ptr load
        copy quotes prs_ch
        string-from-range
        copy-pair asm-string
        add in_adv swap not or not
    loop

    1 add # Trim leading space

    in_ptr load 1 add in_adv drop drop      # Consume closing quote
    0 basm                                  # Null-terminate
    here load
    realign-arena
    string-from-range 1 sub

    mode load if
        pop patch-target
        swap
        lit lit asm
        asm
        lit lit asm
        asm
    end-if
end-fn immediate

fn: next-line \ -- \ nl print end-fn

fn: start
    \ -- \
    s" Mini (C) 2023 David Detweiler" println
    s" Enter `kernel walk` to see the list of instructions defined by the kernel" println
    next-line
    stdin load
    in store
end-fn

start
